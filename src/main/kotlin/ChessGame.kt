package org.example/* Класс игры.*Игровой класс через который реализованна все взаимодействие с игрой.*Имеет свойства:*   -список игроков(по цветам)*   -список взятых фигур(map в котором ключем является игрок(цвет) а значением список фигур взятых этим игроком у другого)*   -текущий игрок*   -шахматная доска*Методы:*   -проверки игры на релевантность(выйграл ли кто-нибудь за предыдущий ход)*   -процесса игры. Главный метод в котором полностью реализуется игра*   -начальное заполнение взятых фигур. В начале игры не у кого же нет взятых фигур потому изначально заполняем пустыми списками*   -вывод инофрмации об игре*   -вывод шахматной доски*   -вывод взятых фигур у каждого игрока*/abstract class ChessGame<X,Y,P: FigurePosition<X,Y>, B: Chessboard<X,Y,P,B,F>, F: ChessFigure<X,Y,P,B,F>>(players: List<ColorPlayer>) {    val playerList: List<ColorPlayer> = players    val capturedPieces: MutableMap<ColorPlayer, MutableList<F>> = fillNullCapturedPiecesMap()    abstract var currentPlayer: ColorPlayer    abstract val chessboard: Chessboard<X,Y,P,B,F>    abstract fun chekGame(): Boolean    abstract fun playGame()    abstract fun fillNullCapturedPiecesMap(): MutableMap<ColorPlayer, MutableList<F>>    abstract fun printGameInfo()    abstract fun printChessBoard()    abstract fun printCapturedPieces()}class ClassicChessGame(_currentPlayer: ColorPlayer): ChessGame<Char,Int,ClassicFigurePosition, ClassicChessboard, ClassicChessFigure> (    listOf(ColorPlayer.WHITE, ColorPlayer.BLACK)) {    override var currentPlayer: ColorPlayer = _currentPlayer    override val chessboard: ClassicChessboard = ClassicChessboard()    override fun chekGame(): Boolean {        TODO("Not yet implemented")    }    override fun playGame() {        var currentPosition: ClassicFigurePosition        var currentFigure: ClassicChessFigure        var newPosition: ClassicFigurePosition        var listPossiblePositions: Set<ClassicFigurePosition>?        var input: String        fun checkCorrectInputPositionAndReturnPosition(input: String): ClassicFigurePosition?{            val letter: Char? = if (input.getOrNull(0)?.uppercaseChar() != null) { // Есть ли такая координата вообще                if(chessboard.checkXCoordinateOnBoard(input[0].uppercaseChar())) input[0].uppercaseChar() else {                    MyLogger.log("[${input.getOrNull(0)?.uppercaseChar()}]Недействительная координата X"); println(MyLogger.lastMessage)                    null                }            }            else {                MyLogger.log("[${input.getOrNull(0)}]не является сиво лом")                println(MyLogger.lastMessage)                null            }            val digit: Int? = if (input.getOrNull(1)?.digitToIntOrNull() != null) {                if (chessboard.checkYCoordinateOnBoard(input[1].digitToInt())) input[1].digitToInt() else {                    MyLogger.log("[${input.getOrNull(1)}]Недействительная координата Y"); println(MyLogger.lastMessage);                    null                }            }            else {                MyLogger.log("[${input.getOrNull(1)}] не является цифрой")                println(MyLogger.lastMessage)                null            }            if (letter != null && digit != null) {                if(chessboard.checkPositionOnBoard(ClassicFigurePosition(letter,digit))){                    return ClassicFigurePosition(letter, digit)                }                return null            } else {                return null            }        }        println("ДОБРО ПОЖАЛОВАТЬ ЕБАНА")        printGameInfo()        printCapturedPieces()        printChessBoard()        while (true) { // тут будет метод checkGame который возвращает false если ход привел к победе одного из игроков или к паритету            while (true) { //Цикл ввода позиций                println("Выберете координаты своей фигуры")                input = readln()                currentPosition = checkCorrectInputPositionAndReturnPosition(input) ?: continue                print("Выбрана позиция [${currentPosition.xCoordinate}${currentPosition.yCoordinate}] ")                currentFigure = chessboard.returnFigureByPosition(currentPosition) ?: run { println("Клетка пуста. Выберите другую"); continue }                if(currentFigure.colorFigure != currentPlayer) { println("Это не твоя фигура еблан"); continue }                println("Фигура: ${ chessboard.returnFigureByPosition(currentPosition)?.charAliasOnChessboard }")                listPossiblePositions = currentFigure.whereCanMakeMove(currentPlayer,currentPosition,chessboard)                if (listPossiblePositions==null){                    MyLogger.log("У фигуры нет клетки для хода. Выберите другую фигуру!")                    println(MyLogger.lastMessage)                    continue                }                //Вывод списка доступных позиций                for (i in listPossiblePositions){                    print("[${i.xCoordinate}${i.yCoordinate}] ")                }                println() //Перевод каретки после цикла                //Цикл проверки правильности введенных данных для новой позиции                while (true){                    println("Выберите координаты клетки для хода")                    input = readln()                    newPosition = checkCorrectInputPositionAndReturnPosition(input) ?: continue                    println("Выбрана позиция [${newPosition.xCoordinate}${newPosition.yCoordinate}]")                    chessboard.makeMove(                        listPossiblePositions,                        currentPosition,                        newPosition                    ) {capturedPiece ->                        capturedPieces[currentPlayer]?.add(capturedPiece)                    }                    break                }                //TODO("РЕЛИЗОВАТЬ МЕТОД ПРОВЕРКИ ИГРЫ НА ПОБЕДУ ИГРОКОВ")                currentPlayer = currentPlayer.next()                printGameInfo()                printCapturedPieces()                printChessBoard()                break            }        }    }    override fun fillNullCapturedPiecesMap(): MutableMap<ColorPlayer, MutableList<ClassicChessFigure>> {        val map = mutableMapOf<ColorPlayer, MutableList<ClassicChessFigure>>()        for (player in playerList){            map[player] = mutableListOf()        }        return map    }    override fun printGameInfo() {        println("Текущий ход: $currentPlayer TODO и какая нибудь еще информация")    }    override fun printChessBoard() {        val ranks = if (currentPlayer == ColorPlayer.WHITE) 8 downTo 1 else 1..8        val files = if (currentPlayer == ColorPlayer.WHITE) 'A'..'H' else 'H' downTo 'A'        fun getSymbol(figure: ClassicChessFigure?): String {            return figure?.charAliasOnChessboard?.toString() ?: "·"        }        println("  ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗")        for (rank in ranks) {            print("$rank ║")            for (file in files) {                val figure = chessboard.returnMapFiguresOnChessboard().entries.find { (pos, _) ->                    pos.xCoordinate == file && pos.yCoordinate == rank                }?.value                print(" ${getSymbol(figure)} ║")            }            println()            if (rank != ranks.last()) {                println("  ╟───┼───┼───┼───┼───┼───┼───┼───╢")            }        }        println("  ╚═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╝")        val bottomFiles = if (currentPlayer == ColorPlayer.WHITE)            listOf('A','B','C','D','E','F','G','H')        else            listOf('H','G','F','E','D','C','B','A')        println("    " + bottomFiles.joinToString("   "))    }    override fun printCapturedPieces() {        val capturedPiecesList = capturedPieces[currentPlayer]        println("Взятые фигуры: ")        if (capturedPiecesList!=null) {            for (i in capturedPiecesList){                print("${i.charAliasOnChessboard},")            }        }        println()    }}